
In computer programming, you can make something faster at the cost of needing more (random access) memory or decrease its memory needs at the cost of being slower. A lot of computer evolution, both in hardware and software, has been finding ways to improve the exchange rate or just straight increase the number of resources available to fiddle with.

freeCodeCamp dev quiz - Software Design

- The five phases of the Design Thinking Process are Empathize, Define, Ideate, Prototype, and Test.
- what is grep?
- The Design Thinking Process is a way to come up with creative, user centric solutions to complex problems.
- [The Design Thinking Process Explained](https://www.freecodecamp.org/news/the-design-thinking-process-explained)
- When Pair Programming, one developer is the "driver" with their hands on the keyboard. The other is the "navigator" helping talk through the problem and decide what to do. They periodically switch roles. This is an efficient and commonly used Agile Software Development methodology.

Software needs the ability to code events and objects in such a way
that rough-and-ready versions of statistical principles can be applied
to them.

A building or object should let you use it as you want: a good building,
for example, will serve as a backdrop for whatever life people want to
lead in it, instead of making them live as if they were executing a
program written by the architect.

Hackers need to understand the theory of computation about as much as
painters need to understand paint chemistry.

You should figure out programs as you're writing them, just as writers
and painters and architects do. Realizing this has real implications for
software design. It means that a programming language should, above all,
be malleable. A programming language is for thinking of programs, not
for expressing programs you've already thought of. It should be a
pencil, not a pen.

There are quite a few occasions where an already-present tool should be rebuilt:  
- It's often hard to find _precisely_ what you want, and refactoring can be complicated.
- Some software developers reinvent the wheel or [reverse-engineer something](https://trendless.tech/hacking), just for fun.
- Reinventing the wheel is very educational, even if its results aren't always useful.
- An existing tool might become obsolete, jammed behind a paywall, merged into some bloated software suite, or the software's owner [became tyrannical](https://gainedin.site/bad-systems/) over [their IP](https://notageni.us/ip).
- For any reason whatsoever, a developer may start distrusting software and will make a lobotomized or [open-source](https://trendless.tech/floss/) version of it.
The largest mental wall for most people, though, is knowing a tool even _exists_. If we know another human already did something, we now know it's completely possible, and it's much easier to find motivation to accomplish what we're certain can happen.
